# ğŸ—ï¸ E-Commerce Microservices Architecture Guide

## ğŸ“‹ Ãndice

1. [VisÃ£o Geral](#visÃ£o-geral)
2. [Arquitetura dos ServiÃ§os](#arquitetura-dos-serviÃ§os)
3. [PadrÃµes Implementados](#padrÃµes-implementados)
4. [ComunicaÃ§Ã£o entre ServiÃ§os](#comunicaÃ§Ã£o-entre-serviÃ§os)
5. [Deployment](#deployment)
6. [Guia de MigraÃ§Ã£o](#guia-de-migraÃ§Ã£o)
7. [Monitoramento e Observabilidade](#monitoramento)

---

## ğŸ¯ VisÃ£o Geral

### ServiÃ§os Criados

| ServiÃ§o                  | Responsabilidade                           | Database          | Port |
| ------------------------ | ------------------------------------------ | ----------------- | ---- |
| **Identity Service**     | AutenticaÃ§Ã£o, UsuÃ¡rios, EndereÃ§os, CartÃµes | `identity_db`     | 3001 |
| **Catalog Service**      | Produtos, Categorias, Reviews, Favoritos   | `catalog_db`      | 3002 |
| **Cart Service**         | Carrinhos, Carrinhos Abandonados           | `cart_db`         | 3003 |
| **Order Service**        | Pedidos, Pagamentos, Tracking              | `order_db`        | 3004 |
| **Promotion Service**    | Cupons, Campanhas, Descontos               | `promotion_db`    | 3005 |
| **Notification Service** | Emails, SMS, Push, Templates               | `notification_db` | 3006 |

---

## ğŸ›ï¸ Arquitetura dos ServiÃ§os

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      API Gateway / BFF                       â”‚
â”‚              (Kong, AWS API Gateway, Custom)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚                  â”‚                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚   Identity  â”‚    â”‚   Catalog   â”‚   â”‚    Cart     â”‚
    â”‚   Service   â”‚    â”‚   Service   â”‚   â”‚   Service   â”‚
    â”‚             â”‚    â”‚             â”‚   â”‚             â”‚
    â”‚ identity_db â”‚    â”‚ catalog_db  â”‚   â”‚  cart_db    â”‚
    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
           â”‚                  â”‚                  â”‚
           â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
           â”‚         â”‚  Message Broker â”‚         â”‚
           â”‚         â”‚ (RabbitMQ/Kafka)â”‚         â”‚
           â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
           â”‚                  â”‚                  â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
    â”‚    Order    â”‚    â”‚  Promotion  â”‚   â”‚Notification â”‚
    â”‚   Service   â”‚    â”‚   Service   â”‚   â”‚  Service    â”‚
    â”‚             â”‚    â”‚             â”‚   â”‚             â”‚
    â”‚  order_db   â”‚    â”‚promotion_db â”‚   â”‚notification â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ”§ PadrÃµes Implementados

### 1. **Database per Service**

Cada serviÃ§o possui seu prÃ³prio banco de dados PostgreSQL isolado:

```yaml
# docker-compose.yml
services:
  identity-db:
    image: postgres:15
    environment:
      POSTGRES_DB: identity_db

  catalog-db:
    image: postgres:15
    environment:
      POSTGRES_DB: catalog_db
```

### 2. **Transactional Outbox Pattern**

Garante consistÃªncia eventual publicando eventos na mesma transaÃ§Ã£o:

```sql
-- Toda mudanÃ§a gera evento no outbox
CREATE TRIGGER publish_user_created
    AFTER INSERT ON users
    FOR EACH ROW EXECUTE FUNCTION publish_user_event();

-- Worker separado publica para message broker
SELECT * FROM outbox_events WHERE status = 'PENDING';
```

### 3. **Inbox Pattern (DeduplicaÃ§Ã£o)**

Previne processamento duplicado de eventos:

```sql
-- Antes de processar evento
INSERT INTO inbox_events (id, event_type, aggregate_id)
VALUES (event_id, 'OrderCompleted', order_id)
ON CONFLICT (id) DO NOTHING
RETURNING id;

-- Se retornar NULL = jÃ¡ processado
```

### 4. **Saga Pattern (Orchestration)**

Coordena transaÃ§Ãµes distribuÃ­das com compensaÃ§Ã£o:

```sql
-- Order Service gerencia saga de criaÃ§Ã£o de pedido
CREATE TABLE order_sagas (
    id UUID PRIMARY KEY,
    order_id UUID,
    saga_type VARCHAR(100), -- CREATE_ORDER, CANCEL_ORDER
    status saga_status,
    current_step INT,
    steps JSONB -- Array de passos e status
);
```

**Exemplo de Saga:**

```
CREATE_ORDER:
1. ReserveInventory (Catalog Service)
2. ValidateCoupon (Promotion Service)
3. ProcessPayment (Payment Gateway)
4. ConvertCart (Cart Service)
5. SendConfirmation (Notification Service)

Se qualquer passo falhar â†’ compensaÃ§Ã£o reversa
```

### 5. **CQRS (Command Query Responsibility Segregation)**

SeparaÃ§Ã£o de leitura e escrita:

```sql
-- Command: Tabelas normalizadas
INSERT INTO products (...);

-- Query: Views/Materialized Views otimizadas
CREATE MATERIALIZED VIEW product_catalog AS
SELECT p.*, c.name AS category_name, ...
FROM products p JOIN categories c ...;
```

### 6. **Event Sourcing**

HistÃ³rico completo de mudanÃ§as:

```sql
-- Cart Service armazena todos os eventos
CREATE TABLE cart_events (
    id UUID PRIMARY KEY,
    cart_id UUID,
    event_type cart_event_type, -- ITEM_ADDED, ITEM_REMOVED
    event_data JSONB,
    created_at TIMESTAMP
);

-- Pode reconstruir estado do carrinho
SELECT * FROM cart_events WHERE cart_id = '...' ORDER BY created_at;
```

### 7. **Snapshot Pattern**

Anti-corruption layer para dados externos:

```sql
-- Order armazena snapshot de endereÃ§o
address_snapshot JSONB NOT NULL
-- {
--   "street": "...",
--   "city": "...",
--   "state": "..."
-- }

-- Mesmo se Identity Service mudar o endereÃ§o,
-- o pedido mantÃ©m dados histÃ³ricos
```

---

## ğŸ”Œ ComunicaÃ§Ã£o entre ServiÃ§os

### ComunicaÃ§Ã£o SÃ­ncrona (API REST/gRPC)

**Quando usar:**

- Leitura de dados (queries)
- ValidaÃ§Ãµes em tempo real
- OperaÃ§Ãµes crÃ­ticas que precisam de resposta imediata

**Exemplo:**

```javascript
// Cart Service valida produto com Catalog Service
const product = await catalogClient.getProduct(productId);
if (!product || !product.is_active || product.stock < quantity) {
  throw new Error("Product unavailable");
}
```

**ImplementaÃ§Ã£o:**

```javascript
// catalog-service/api/products.js
app.get("/products/:id", async (req, res) => {
  const product = await db.query(
    "SELECT * FROM products WHERE id = $1 AND deleted_at IS NULL",
    [req.params.id]
  );
  res.json(product);
});
```

### ComunicaÃ§Ã£o AssÃ­ncrona (Message Broker)

**Quando usar:**

- Eventos de domÃ­nio (OrderCreated, UserRegistered)
- Processamento background
- Fan-out (1 evento â†’ N consumidores)

**Exemplo com RabbitMQ:**

```javascript
// Order Service publica evento
await publishEvent("order.created", {
  order_id: order.id,
  user_id: order.user_id,
  total: order.total,
});

// Consumidores
// Cart Service: marca carrinho como convertido
// Notification Service: envia email de confirmaÃ§Ã£o
// Analytics Service: registra venda
```

**Outbox Publisher (CDC - Change Data Capture):**

```javascript
// outbox-publisher.js
setInterval(async () => {
  const events = await db.query(`
        SELECT * FROM outbox_events 
        WHERE status = 'PENDING' 
        LIMIT 100
        FOR UPDATE SKIP LOCKED
    `);

  for (const event of events) {
    await rabbitmq.publish(event.event_type, event.payload);

    await db.query(
      `
            UPDATE outbox_events 
            SET status = 'PUBLISHED', published_at = now()
            WHERE id = $1
        `,
      [event.id]
    );
  }
}, 1000);
```

---

## ğŸ³ Deployment

### Docker Compose (Desenvolvimento)

```yaml
version: "3.9"

services:
  # Databases
  identity-db:
    image: postgres:15
    environment:
      POSTGRES_DB: identity_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - identity_data:/var/lib/postgresql/data
      - ./identity-service/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql
    ports:
      - "5432:5432"

  catalog-db:
    image: postgres:15
    environment:
      POSTGRES_DB: catalog_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - catalog_data:/var/lib/postgresql/data
      - ./catalog-service/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql
    ports:
      - "5433:5432"

  # Message Broker
  rabbitmq:
    image: rabbitmq:3.12-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: admin

  # Services
  identity-service:
    build: ./identity-service
    ports:
      - "3001:3000"
    environment:
      DATABASE_URL: postgresql://postgres:postgres@identity-db:5432/identity_db
      RABBITMQ_URL: amqp://admin:admin@rabbitmq:5672
      JWT_SECRET: your-secret-key
    depends_on:
      - identity-db
      - rabbitmq

  catalog-service:
    build: ./catalog-service
    ports:
      - "3002:3000"
    environment:
      DATABASE_URL: postgresql://postgres:postgres@catalog-db:5432/catalog_db
      RABBITMQ_URL: amqp://admin:admin@rabbitmq:5672
    depends_on:
      - catalog-db
      - rabbitmq

  # API Gateway
  kong:
    image: kong:3.4
    ports:
      - "8000:8000"
      - "8001:8001"
    environment:
      KONG_DATABASE: "off"
      KONG_DECLARATIVE_CONFIG: /kong/kong.yml
    volumes:
      - ./kong.yml:/kong/kong.yml

volumes:
  identity_data:
  catalog_data:
  cart_data:
  order_data:
  promotion_data:
  notification_data:
```

### Kubernetes (ProduÃ§Ã£o)

```yaml
# identity-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: identity-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: identity-service
  template:
    metadata:
      labels:
        app: identity-service
    spec:
      containers:
        - name: identity-service
          image: your-registry/identity-service:latest
          ports:
            - containerPort: 3000
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: identity-db-secret
                  key: connection-string
            - name: RABBITMQ_URL
              valueFrom:
                secretKeyRef:
                  name: rabbitmq-secret
                  key: connection-string
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: identity-service
spec:
  selector:
    app: identity-service
  ports:
    - port: 80
      targetPort: 3000
  type: ClusterIP
```

---

## ğŸ”„ Guia de MigraÃ§Ã£o

### Fase 1: SeparaÃ§Ã£o LÃ³gica (Schema Isolation)

**DuraÃ§Ã£o: 1-2 semanas**

```sql
-- No banco monolÃ­tico, criar schemas separados
CREATE SCHEMA identity_service;
CREATE SCHEMA catalog_service;
CREATE SCHEMA cart_service;

-- Mover tabelas para schemas
ALTER TABLE users SET SCHEMA identity_service;
ALTER TABLE products SET SCHEMA catalog_service;

-- AplicaÃ§Ãµes acessam apenas seu schema
-- identity-service: SET search_path TO identity_service;
```

### Fase 2: Implementar Outbox/Inbox

**DuraÃ§Ã£o: 2-3 semanas**

```sql
-- Adicionar outbox em cada schema
CREATE TABLE identity_service.outbox_events (...);
CREATE TABLE catalog_service.outbox_events (...);

-- Criar triggers para publicar eventos
CREATE TRIGGER publish_user_event ...

-- Implementar outbox publisher worker
```

### Fase 3: Remover Foreign Keys Cross-Schema

**DuraÃ§Ã£o: 1 semana**

```sql
-- Antes
ALTER TABLE cart_items
    DROP CONSTRAINT fk_cart_items_product_id;

-- Depois: validaÃ§Ã£o via API ou evento
-- Application code valida produto existe
```

### Fase 4: SeparaÃ§Ã£o FÃ­sica (Bancos Separados)

**DuraÃ§Ã£o: 3-4 semanas**

```bash
# Dump de cada schema
pg_dump -n identity_service monolith_db > identity.sql

# Restore em novo banco
psql identity_db < identity.sql

# Update connection strings
# identity-service â†’ identity_db
# catalog-service â†’ catalog_db
```

### Fase 5: MigraÃ§Ã£o de Dados com Dual Write

**Durante migraÃ§Ã£o:**

```javascript
// Escreve no banco antigo E novo
async function createUser(data) {
  // Banco antigo (deprecado)
  await legacyDb.query("INSERT INTO users ...");

  // Banco novo
  await newDb.query("INSERT INTO users ...");

  // Comparar resultados em background
}
```

### Fase 6: ValidaÃ§Ã£o e Switchover

```javascript
// Feature flag para controlar leitura
if (featureFlags.useNewDb) {
  return await identityService.getUser(id);
} else {
  return await legacyDb.getUser(id);
}

// Monitorar mÃ©tricas, aumentar % gradualmente
// 10% â†’ 50% â†’ 100%
```

---

## ğŸ“Š Monitoramento e Observabilidade

### Logs Estruturados

```javascript
// Formato JSON com correlation_id
logger.info({
  message: "Order created",
  order_id: order.id,
  user_id: order.user_id,
  correlation_id: req.correlationId,
  service: "order-service",
  timestamp: new Date().toISOString(),
});
```

### MÃ©tricas (Prometheus)

```javascript
// Contador de eventos processados
const eventsProcessed = new Counter({
  name: "outbox_events_processed_total",
  help: "Total outbox events processed",
  labelNames: ["service", "event_type", "status"],
});

eventsProcessed.inc({
  service: "order-service",
  event_type: "OrderCreated",
  status: "success",
});
```

### Tracing DistribuÃ­do (Jaeger/OpenTelemetry)

```javascript
const span = tracer.startSpan("create_order");
span.setTag("user_id", userId);

try {
  // OperaÃ§Ãµes do serviÃ§o
  const order = await createOrder(data);
  span.setTag("order_id", order.id);
} catch (error) {
  span.setTag("error", true);
  span.log({ event: "error", message: error.message });
} finally {
  span.finish();
}
```

### Health Checks

```javascript
// /health endpoint
app.get("/health", async (req, res) => {
  const checks = {
    database: await checkDatabase(),
    rabbitmq: await checkRabbitMQ(),
    redis: await checkRedis(),
  };

  const healthy = Object.values(checks).every((c) => c.healthy);

  res.status(healthy ? 200 : 503).json({
    status: healthy ? "healthy" : "unhealthy",
    checks,
    timestamp: new Date().toISOString(),
  });
});
```

---

## ğŸ” SeguranÃ§a

### Service-to-Service Authentication (JWT)

```javascript
// identity-service emite JWT para outros serviÃ§os
const serviceToken = jwt.sign(
  { service: "cart-service", scope: "read:products" },
  SERVICE_SECRET,
  { expiresIn: "1h" }
);

// catalog-service valida token
app.use("/internal", verifyServiceToken);
```

### API Gateway (Rate Limiting, Auth)

```yaml
# kong.yml
services:
  - name: identity-service
    url: http://identity-service:3000
    routes:
      - name: auth-routes
        paths:
          - /api/auth
    plugins:
      - name: rate-limiting
        config:
          minute: 100
          hour: 1000
      - name: jwt
        config:
          secret_is_base64: false
```

---

## ğŸ“š ReferÃªncias e PrÃ³ximos Passos

### Melhorias Futuras

1. **Circuit Breaker Pattern** (Hystrix/Resilience4j)
2. **API Gateway com GraphQL** (Federation)
3. **Event Replay** para reprocessamento
4. **CQRS avanÃ§ado** com Event Store dedicado
5. **Multi-tenancy** (dados por tenant)
6. **Feature Flags** (LaunchDarkly/Unleash)

### Comandos Ãšteis

```bash
# Iniciar todos os serviÃ§os
docker-compose up -d

# Ver logs de um serviÃ§o
docker-compose logs -f identity-service

# Executar migrations
docker-compose exec identity-db psql -U postgres -d identity_db -f /schema.sql

# Acessar RabbitMQ Management
open http://localhost:15672 # admin/admin

# Monitorar outbox events
watch -n 1 'docker-compose exec identity-db psql -U postgres -d identity_db -c "SELECT status, count(*) FROM outbox_events GROUP BY status"'
```

---

## ğŸ“ ConclusÃ£o

Esta arquitetura implementa:

âœ… **SeparaÃ§Ã£o completa** de banco de dados por serviÃ§o  
âœ… **ConsistÃªncia eventual** via Transactional Outbox  
âœ… **DeduplicaÃ§Ã£o** de eventos com Inbox Pattern  
âœ… **CoordenaÃ§Ã£o** de transaÃ§Ãµes distribuÃ­das com Saga  
âœ… **Rastreabilidade** completa com Event Sourcing  
âœ… **Snapshots** para anti-corruption layer  
âœ… **CQRS** para otimizaÃ§Ã£o de leitura

**Resultado:** Sistema altamente escalÃ¡vel, resiliente e com deploy independente de cada serviÃ§o! ğŸš€
