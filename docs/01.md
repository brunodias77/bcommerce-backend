# 🏗️ E-Commerce Microservices Architecture Guide

## 📋 Índice

1. [Visão Geral](#visão-geral)
2. [Arquitetura dos Serviços](#arquitetura-dos-serviços)
3. [Padrões Implementados](#padrões-implementados)
4. [Comunicação entre Serviços](#comunicação-entre-serviços)
5. [Deployment](#deployment)
6. [Guia de Migração](#guia-de-migração)
7. [Monitoramento e Observabilidade](#monitoramento)

---

## 🎯 Visão Geral

### Serviços Criados

| Serviço                  | Responsabilidade                           | Database          | Port |
| ------------------------ | ------------------------------------------ | ----------------- | ---- |
| **Identity Service**     | Autenticação, Usuários, Endereços, Cartões | `identity_db`     | 3001 |
| **Catalog Service**      | Produtos, Categorias, Reviews, Favoritos   | `catalog_db`      | 3002 |
| **Cart Service**         | Carrinhos, Carrinhos Abandonados           | `cart_db`         | 3003 |
| **Order Service**        | Pedidos, Pagamentos, Tracking              | `order_db`        | 3004 |
| **Promotion Service**    | Cupons, Campanhas, Descontos               | `promotion_db`    | 3005 |
| **Notification Service** | Emails, SMS, Push, Templates               | `notification_db` | 3006 |

---

## 🏛️ Arquitetura dos Serviços

```
┌─────────────────────────────────────────────────────────────┐
│                      API Gateway / BFF                       │
│              (Kong, AWS API Gateway, Custom)                 │
└─────────────────────────────────────────────────────────────┘
                              │
           ┌──────────────────┼──────────────────┐
           │                  │                  │
    ┌──────▼──────┐    ┌──────▼──────┐   ┌──────▼──────┐
    │   Identity  │    │   Catalog   │   │    Cart     │
    │   Service   │    │   Service   │   │   Service   │
    │             │    │             │   │             │
    │ identity_db │    │ catalog_db  │   │  cart_db    │
    └──────┬──────┘    └──────┬──────┘   └──────┬──────┘
           │                  │                  │
           │         ┌────────▼────────┐         │
           │         │  Message Broker │         │
           │         │ (RabbitMQ/Kafka)│         │
           │         └────────┬────────┘         │
           │                  │                  │
    ┌──────▼──────┐    ┌──────▼──────┐   ┌──────▼──────┐
    │    Order    │    │  Promotion  │   │Notification │
    │   Service   │    │   Service   │   │  Service    │
    │             │    │             │   │             │
    │  order_db   │    │promotion_db │   │notification │
    └─────────────┘    └─────────────┘   └─────────────┘
```

---

## 🔧 Padrões Implementados

### 1. **Database per Service**

Cada serviço possui seu próprio banco de dados PostgreSQL isolado:

```yaml
# docker-compose.yml
services:
  identity-db:
    image: postgres:15
    environment:
      POSTGRES_DB: identity_db

  catalog-db:
    image: postgres:15
    environment:
      POSTGRES_DB: catalog_db
```

### 2. **Transactional Outbox Pattern**

Garante consistência eventual publicando eventos na mesma transação:

```sql
-- Toda mudança gera evento no outbox
CREATE TRIGGER publish_user_created
    AFTER INSERT ON users
    FOR EACH ROW EXECUTE FUNCTION publish_user_event();

-- Worker separado publica para message broker
SELECT * FROM outbox_events WHERE status = 'PENDING';
```

### 3. **Inbox Pattern (Deduplicação)**

Previne processamento duplicado de eventos:

```sql
-- Antes de processar evento
INSERT INTO inbox_events (id, event_type, aggregate_id)
VALUES (event_id, 'OrderCompleted', order_id)
ON CONFLICT (id) DO NOTHING
RETURNING id;

-- Se retornar NULL = já processado
```

### 4. **Saga Pattern (Orchestration)**

Coordena transações distribuídas com compensação:

```sql
-- Order Service gerencia saga de criação de pedido
CREATE TABLE order_sagas (
    id UUID PRIMARY KEY,
    order_id UUID,
    saga_type VARCHAR(100), -- CREATE_ORDER, CANCEL_ORDER
    status saga_status,
    current_step INT,
    steps JSONB -- Array de passos e status
);
```

**Exemplo de Saga:**

```
CREATE_ORDER:
1. ReserveInventory (Catalog Service)
2. ValidateCoupon (Promotion Service)
3. ProcessPayment (Payment Gateway)
4. ConvertCart (Cart Service)
5. SendConfirmation (Notification Service)

Se qualquer passo falhar → compensação reversa
```

### 5. **CQRS (Command Query Responsibility Segregation)**

Separação de leitura e escrita:

```sql
-- Command: Tabelas normalizadas
INSERT INTO products (...);

-- Query: Views/Materialized Views otimizadas
CREATE MATERIALIZED VIEW product_catalog AS
SELECT p.*, c.name AS category_name, ...
FROM products p JOIN categories c ...;
```

### 6. **Event Sourcing**

Histórico completo de mudanças:

```sql
-- Cart Service armazena todos os eventos
CREATE TABLE cart_events (
    id UUID PRIMARY KEY,
    cart_id UUID,
    event_type cart_event_type, -- ITEM_ADDED, ITEM_REMOVED
    event_data JSONB,
    created_at TIMESTAMP
);

-- Pode reconstruir estado do carrinho
SELECT * FROM cart_events WHERE cart_id = '...' ORDER BY created_at;
```

### 7. **Snapshot Pattern**

Anti-corruption layer para dados externos:

```sql
-- Order armazena snapshot de endereço
address_snapshot JSONB NOT NULL
-- {
--   "street": "...",
--   "city": "...",
--   "state": "..."
-- }

-- Mesmo se Identity Service mudar o endereço,
-- o pedido mantém dados históricos
```

---

## 🔌 Comunicação entre Serviços

### Comunicação Síncrona (API REST/gRPC)

**Quando usar:**

- Leitura de dados (queries)
- Validações em tempo real
- Operações críticas que precisam de resposta imediata

**Exemplo:**

```javascript
// Cart Service valida produto com Catalog Service
const product = await catalogClient.getProduct(productId);
if (!product || !product.is_active || product.stock < quantity) {
  throw new Error("Product unavailable");
}
```

**Implementação:**

```javascript
// catalog-service/api/products.js
app.get("/products/:id", async (req, res) => {
  const product = await db.query(
    "SELECT * FROM products WHERE id = $1 AND deleted_at IS NULL",
    [req.params.id]
  );
  res.json(product);
});
```

### Comunicação Assíncrona (Message Broker)

**Quando usar:**

- Eventos de domínio (OrderCreated, UserRegistered)
- Processamento background
- Fan-out (1 evento → N consumidores)

**Exemplo com RabbitMQ:**

```javascript
// Order Service publica evento
await publishEvent("order.created", {
  order_id: order.id,
  user_id: order.user_id,
  total: order.total,
});

// Consumidores
// Cart Service: marca carrinho como convertido
// Notification Service: envia email de confirmação
// Analytics Service: registra venda
```

**Outbox Publisher (CDC - Change Data Capture):**

```javascript
// outbox-publisher.js
setInterval(async () => {
  const events = await db.query(`
        SELECT * FROM outbox_events 
        WHERE status = 'PENDING' 
        LIMIT 100
        FOR UPDATE SKIP LOCKED
    `);

  for (const event of events) {
    await rabbitmq.publish(event.event_type, event.payload);

    await db.query(
      `
            UPDATE outbox_events 
            SET status = 'PUBLISHED', published_at = now()
            WHERE id = $1
        `,
      [event.id]
    );
  }
}, 1000);
```

---

## 🐳 Deployment

### Docker Compose (Desenvolvimento)

```yaml
version: "3.9"

services:
  # Databases
  identity-db:
    image: postgres:15
    environment:
      POSTGRES_DB: identity_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - identity_data:/var/lib/postgresql/data
      - ./identity-service/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql
    ports:
      - "5432:5432"

  catalog-db:
    image: postgres:15
    environment:
      POSTGRES_DB: catalog_db
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - catalog_data:/var/lib/postgresql/data
      - ./catalog-service/schema.sql:/docker-entrypoint-initdb.d/01-schema.sql
    ports:
      - "5433:5432"

  # Message Broker
  rabbitmq:
    image: rabbitmq:3.12-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: admin

  # Services
  identity-service:
    build: ./identity-service
    ports:
      - "3001:3000"
    environment:
      DATABASE_URL: postgresql://postgres:postgres@identity-db:5432/identity_db
      RABBITMQ_URL: amqp://admin:admin@rabbitmq:5672
      JWT_SECRET: your-secret-key
    depends_on:
      - identity-db
      - rabbitmq

  catalog-service:
    build: ./catalog-service
    ports:
      - "3002:3000"
    environment:
      DATABASE_URL: postgresql://postgres:postgres@catalog-db:5432/catalog_db
      RABBITMQ_URL: amqp://admin:admin@rabbitmq:5672
    depends_on:
      - catalog-db
      - rabbitmq

  # API Gateway
  kong:
    image: kong:3.4
    ports:
      - "8000:8000"
      - "8001:8001"
    environment:
      KONG_DATABASE: "off"
      KONG_DECLARATIVE_CONFIG: /kong/kong.yml
    volumes:
      - ./kong.yml:/kong/kong.yml

volumes:
  identity_data:
  catalog_data:
  cart_data:
  order_data:
  promotion_data:
  notification_data:
```

### Kubernetes (Produção)

```yaml
# identity-service-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: identity-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: identity-service
  template:
    metadata:
      labels:
        app: identity-service
    spec:
      containers:
        - name: identity-service
          image: your-registry/identity-service:latest
          ports:
            - containerPort: 3000
          env:
            - name: DATABASE_URL
              valueFrom:
                secretKeyRef:
                  name: identity-db-secret
                  key: connection-string
            - name: RABBITMQ_URL
              valueFrom:
                secretKeyRef:
                  name: rabbitmq-secret
                  key: connection-string
          resources:
            requests:
              memory: "256Mi"
              cpu: "250m"
            limits:
              memory: "512Mi"
              cpu: "500m"
          livenessProbe:
            httpGet:
              path: /health
              port: 3000
            initialDelaySeconds: 30
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /ready
              port: 3000
            initialDelaySeconds: 5
            periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: identity-service
spec:
  selector:
    app: identity-service
  ports:
    - port: 80
      targetPort: 3000
  type: ClusterIP
```

---

## 🔄 Guia de Migração

### Fase 1: Separação Lógica (Schema Isolation)

**Duração: 1-2 semanas**

```sql
-- No banco monolítico, criar schemas separados
CREATE SCHEMA identity_service;
CREATE SCHEMA catalog_service;
CREATE SCHEMA cart_service;

-- Mover tabelas para schemas
ALTER TABLE users SET SCHEMA identity_service;
ALTER TABLE products SET SCHEMA catalog_service;

-- Aplicações acessam apenas seu schema
-- identity-service: SET search_path TO identity_service;
```

### Fase 2: Implementar Outbox/Inbox

**Duração: 2-3 semanas**

```sql
-- Adicionar outbox em cada schema
CREATE TABLE identity_service.outbox_events (...);
CREATE TABLE catalog_service.outbox_events (...);

-- Criar triggers para publicar eventos
CREATE TRIGGER publish_user_event ...

-- Implementar outbox publisher worker
```

### Fase 3: Remover Foreign Keys Cross-Schema

**Duração: 1 semana**

```sql
-- Antes
ALTER TABLE cart_items
    DROP CONSTRAINT fk_cart_items_product_id;

-- Depois: validação via API ou evento
-- Application code valida produto existe
```

### Fase 4: Separação Física (Bancos Separados)

**Duração: 3-4 semanas**

```bash
# Dump de cada schema
pg_dump -n identity_service monolith_db > identity.sql

# Restore em novo banco
psql identity_db < identity.sql

# Update connection strings
# identity-service → identity_db
# catalog-service → catalog_db
```

### Fase 5: Migração de Dados com Dual Write

**Durante migração:**

```javascript
// Escreve no banco antigo E novo
async function createUser(data) {
  // Banco antigo (deprecado)
  await legacyDb.query("INSERT INTO users ...");

  // Banco novo
  await newDb.query("INSERT INTO users ...");

  // Comparar resultados em background
}
```

### Fase 6: Validação e Switchover

```javascript
// Feature flag para controlar leitura
if (featureFlags.useNewDb) {
  return await identityService.getUser(id);
} else {
  return await legacyDb.getUser(id);
}

// Monitorar métricas, aumentar % gradualmente
// 10% → 50% → 100%
```

---

## 📊 Monitoramento e Observabilidade

### Logs Estruturados

```javascript
// Formato JSON com correlation_id
logger.info({
  message: "Order created",
  order_id: order.id,
  user_id: order.user_id,
  correlation_id: req.correlationId,
  service: "order-service",
  timestamp: new Date().toISOString(),
});
```

### Métricas (Prometheus)

```javascript
// Contador de eventos processados
const eventsProcessed = new Counter({
  name: "outbox_events_processed_total",
  help: "Total outbox events processed",
  labelNames: ["service", "event_type", "status"],
});

eventsProcessed.inc({
  service: "order-service",
  event_type: "OrderCreated",
  status: "success",
});
```

### Tracing Distribuído (Jaeger/OpenTelemetry)

```javascript
const span = tracer.startSpan("create_order");
span.setTag("user_id", userId);

try {
  // Operações do serviço
  const order = await createOrder(data);
  span.setTag("order_id", order.id);
} catch (error) {
  span.setTag("error", true);
  span.log({ event: "error", message: error.message });
} finally {
  span.finish();
}
```

### Health Checks

```javascript
// /health endpoint
app.get("/health", async (req, res) => {
  const checks = {
    database: await checkDatabase(),
    rabbitmq: await checkRabbitMQ(),
    redis: await checkRedis(),
  };

  const healthy = Object.values(checks).every((c) => c.healthy);

  res.status(healthy ? 200 : 503).json({
    status: healthy ? "healthy" : "unhealthy",
    checks,
    timestamp: new Date().toISOString(),
  });
});
```

---

## 🔐 Segurança

### Service-to-Service Authentication (JWT)

```javascript
// identity-service emite JWT para outros serviços
const serviceToken = jwt.sign(
  { service: "cart-service", scope: "read:products" },
  SERVICE_SECRET,
  { expiresIn: "1h" }
);

// catalog-service valida token
app.use("/internal", verifyServiceToken);
```

### API Gateway (Rate Limiting, Auth)

```yaml
# kong.yml
services:
  - name: identity-service
    url: http://identity-service:3000
    routes:
      - name: auth-routes
        paths:
          - /api/auth
    plugins:
      - name: rate-limiting
        config:
          minute: 100
          hour: 1000
      - name: jwt
        config:
          secret_is_base64: false
```

---

## 📚 Referências e Próximos Passos

### Melhorias Futuras

1. **Circuit Breaker Pattern** (Hystrix/Resilience4j)
2. **API Gateway com GraphQL** (Federation)
3. **Event Replay** para reprocessamento
4. **CQRS avançado** com Event Store dedicado
5. **Multi-tenancy** (dados por tenant)
6. **Feature Flags** (LaunchDarkly/Unleash)

### Comandos Úteis

```bash
# Iniciar todos os serviços
docker-compose up -d

# Ver logs de um serviço
docker-compose logs -f identity-service

# Executar migrations
docker-compose exec identity-db psql -U postgres -d identity_db -f /schema.sql

# Acessar RabbitMQ Management
open http://localhost:15672 # admin/admin

# Monitorar outbox events
watch -n 1 'docker-compose exec identity-db psql -U postgres -d identity_db -c "SELECT status, count(*) FROM outbox_events GROUP BY status"'
```

---

## 🎓 Conclusão

Esta arquitetura implementa:

✅ **Separação completa** de banco de dados por serviço  
✅ **Consistência eventual** via Transactional Outbox  
✅ **Deduplicação** de eventos com Inbox Pattern  
✅ **Coordenação** de transações distribuídas com Saga  
✅ **Rastreabilidade** completa com Event Sourcing  
✅ **Snapshots** para anti-corruption layer  
✅ **CQRS** para otimização de leitura

**Resultado:** Sistema altamente escalável, resiliente e com deploy independente de cada serviço! 🚀
