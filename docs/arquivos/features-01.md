Analisando seu projeto, vejo que voc√™ j√° est√° no caminho certo usando ApiResponse para padronizar retornos. Vou propor uma abordagem h√≠brida que aproveita o melhor dos dois mundos: exceptions para erros de dom√≠nio e ApiResponse para coordenar respostas.
üéØ Estrat√©gia Recomendada
1. Exce√ß√µes de Dom√≠nio (Domain Layer)
Mantenha exce√ß√µes no dom√≠nio para viola√ß√µes de regras de neg√≥cio:
csharp// Domain/Exceptions/CatalogDomainException.cs
public abstract class CatalogDomainException : Exception
{
    public string Code { get; }
    
    protected CatalogDomainException(string code, string message) 
        : base(message)
    {
        Code = code;
    }
}

// Exce√ß√µes espec√≠ficas
public class ProductNotFoundException : CatalogDomainException
{
    public ProductNotFoundException(Guid productId) 
        : base("PRODUCT_NOT_FOUND", $"Product with ID {productId} not found")
    {
    }
}

public class DuplicateSlugException : CatalogDomainException
{
    public DuplicateSlugException(string slug) 
        : base("DUPLICATE_SLUG", $"Slug '{slug}' already exists")
    {
    }
}

public class InsufficientStockException : CatalogDomainException
{
    public InsufficientStockException(Guid productId, int requested, int available) 
        : base("INSUFFICIENT_STOCK", 
              $"Insufficient stock for product {productId}. Requested: {requested}, Available: {available}")
    {
    }
}
2. Global Exception Handler (API Layer)
Centralize o tratamento de exce√ß√µes:
csharp// Api/Middlewares/GlobalExceptionHandlerMiddleware.cs
public class GlobalExceptionHandlerMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<GlobalExceptionHandlerMiddleware> _logger;
    private readonly IHostEnvironment _env;

    public GlobalExceptionHandlerMiddleware(
        RequestDelegate next, 
        ILogger<GlobalExceptionHandlerMiddleware> logger,
        IHostEnvironment env)
    {
        _next = next;
        _logger = logger;
        _env = env;
    }

    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }

    private async Task HandleExceptionAsync(HttpContext context, Exception exception)
    {
        _logger.LogError(exception, "‚ùå Unhandled exception: {Message}", exception.Message);

        var (statusCode, response) = exception switch
        {
            // Domain Exceptions
            CatalogDomainException domainEx => (
                StatusCodes.Status400BadRequest,
                ApiResponse<object>.Fail(new List<Error> 
                { 
                    new Error(domainEx.Message) 
                })
            ),
            
            ProductNotFoundException => (
                StatusCodes.Status404NotFound,
                ApiResponse<object>.Fail("Product not found")
            ),
            
            DuplicateSlugException => (
                StatusCodes.Status409Conflict,
                ApiResponse<object>.Fail("Slug already exists")
            ),
            
            // Validation Exceptions (from BuildingBlocks)
            ValidationException validationEx => (
                StatusCodes.Status400BadRequest,
                ApiResponse<object>.Fail(validationEx.Errors.ToList())
            ),
            
            // Database Exceptions
            DbUpdateConcurrencyException => (
                StatusCodes.Status409Conflict,
                ApiResponse<object>.Fail("The record was modified by another user")
            ),
            
            DbUpdateException dbEx => (
                StatusCodes.Status500InternalServerError,
                CreateDatabaseErrorResponse(dbEx)
            ),
            
            // Generic fallback
            _ => (
                StatusCodes.Status500InternalServerError,
                CreateGenericErrorResponse(exception)
            )
        };

        context.Response.StatusCode = statusCode;
        context.Response.ContentType = "application/json";
        
        await context.Response.WriteAsJsonAsync(response);
    }

    private ApiResponse<object> CreateDatabaseErrorResponse(DbUpdateException ex)
    {
        // Log completo do erro
        _logger.LogError(ex, "üí• Database error");
        
        // N√£o vaza detalhes em produ√ß√£o
        var message = _env.IsDevelopment() 
            ? $"Database error: {ex.InnerException?.Message ?? ex.Message}"
            : "A database error occurred";
            
        return ApiResponse<object>.Fail(message);
    }

    private ApiResponse<object> CreateGenericErrorResponse(Exception ex)
    {
        _logger.LogCritical(ex, "üí• Critical unhandled exception");
        
        var message = _env.IsDevelopment()
            ? $"Internal server error: {ex.Message}"
            : "An unexpected error occurred";
            
        return ApiResponse<object>.Fail(message);
    }
}

// Extension method para registrar
public static class GlobalExceptionHandlerExtensions
{
    public static IApplicationBuilder UseGlobalExceptionHandler(
        this IApplicationBuilder app)
    {
        return app.UseMiddleware<GlobalExceptionHandlerMiddleware>();
    }
}
3. Command Handlers (Application Layer)
Use try-catch apenas quando necess√°rio para transformar exce√ß√µes:
csharp// Application/Commands/Products/CreateProduct/CreateProductCommandHandler.cs
public class CreateProductCommandHandler 
    : ICommandHandler<CreateProductCommand, ApiResponse<CreateProductResponse>>
{
    private readonly IProductRepository _productRepository;
    private readonly IUnitOfWork _unitOfWork;
    private readonly CreateProductCommandValidator _validator;
    private readonly ILogger<CreateProductCommandHandler> _logger;

    public async Task<ApiResponse<CreateProductResponse>> HandleAsync(
        CreateProductCommand request, 
        CancellationToken cancellationToken = default)
    {
        // 1. Valida√ß√£o com Validator
        var validationResult = _validator.Validate(request);
        if (validationResult.HasErrors)
        {
            _logger.LogWarning("‚ö†Ô∏è Validation failed for CreateProduct: {Errors}", 
                string.Join(", ", validationResult.Errors.Select(e => e.Message)));
            return ApiResponse<CreateProductResponse>.Fail(validationResult.Errors.ToList());
        }

        try
        {
            await _unitOfWork.BeginTransactionAsync(cancellationToken);

            // 2. Verificar duplica√ß√£o (pode lan√ßar DuplicateSlugException)
            var existing = await _productRepository.FindAsync(
                p => p.Slug == request.Slug, 
                cancellationToken);
                
            if (existing.Any())
            {
                // Op√ß√£o 1: Retornar ApiResponse diretamente
                await _unitOfWork.RollbackTransactionAsync(cancellationToken);
                return ApiResponse<CreateProductResponse>.Fail("Product with this slug already exists");
                
                // Op√ß√£o 2: Lan√ßar exce√ß√£o (ser√° capturada pelo middleware)
                // throw new DuplicateSlugException(request.Slug);
            }

            // 3. Criar produto (valida√ß√µes de dom√≠nio podem lan√ßar exce√ß√µes)
            var price = Money.Create(request.Price, request.Currency);
            var product = Product.Create(
                request.Name,
                request.Slug,
                price,
                request.Stock,
                request.Description,
                request.ShortDescription,
                request.CategoryId,
                request.Sku,
                request.IsActive
            );

            // 4. Persistir
            await _productRepository.AddAsync(product, cancellationToken);
            await _unitOfWork.SaveChangesAsync(cancellationToken);
            await _unitOfWork.CommitTransactionAsync(cancellationToken);

            _logger.LogInformation("‚úÖ Product created: {ProductId} - {ProductName}", 
                product.Id, product.Name);

            // 5. Retornar sucesso
            var response = new CreateProductResponse
            {
                Id = product.Id,
                Name = product.Name,
                Slug = product.Slug,
                // ... outros campos
            };

            return ApiResponse<CreateProductResponse>.Ok(
                response, 
                "Product created successfully");
        }
        catch (DomainException ex)
        {
            // Rollback e deixa o middleware tratar
            await _unitOfWork.RollbackTransactionAsync(cancellationToken);
            _logger.LogWarning(ex, "‚ö†Ô∏è Domain validation failed");
            throw; // Middleware converte para ApiResponse
        }
        catch (Exception ex)
        {
            // Rollback em caso de erro inesperado
            await _unitOfWork.RollbackTransactionAsync(cancellationToken);
            _logger.LogError(ex, "üí• Unexpected error creating product");
            throw; // Middleware converte para ApiResponse
        }
    }
}
4. Controllers (API Layer)
Controllers simples, deixam o middleware tratar exce√ß√µes:
csharp// Api/Controllers/ProductController.cs
[HttpPost]
[ProducesResponseType(typeof(ApiResponse<CreateProductResponse>), 201)]
[ProducesResponseType(typeof(ApiResponse<CreateProductResponse>), 400)]
[ProducesResponseType(typeof(ApiResponse<CreateProductResponse>), 409)]
[ProducesResponseType(typeof(ApiResponse<CreateProductResponse>), 500)]
public async Task<IActionResult> CreateProduct(
    [FromBody] CreateProductCommand command, 
    CancellationToken cancellationToken = default)
{
    _logger.LogInformation("üìù Creating product: {ProductName}", command.Name);

    // N√£o precisa de try-catch aqui!
    // O middleware captura tudo
    var result = await _mediator.SendAsync<ApiResponse<CreateProductResponse>>(
        command, 
        cancellationToken);

    if (!result.Success)
    {
        _logger.LogWarning("‚ùå Failed to create product: {Errors}", 
            string.Join(", ", result.Errors?.Select(e => e.Message) ?? []));
        return BadRequest(result);
    }

    _logger.LogInformation("‚úÖ Product created successfully: {ProductId}", result.Data.Id);
    
    return CreatedAtAction(
        nameof(GetProductById),
        new { id = result.Data.Id },
        result);
}
5. Configura√ß√£o no Program.cs
csharp// Program.cs

// ORDEM IMPORTANT√çSSIMA!
var app = builder.Build();

// 1. Logging de requisi√ß√µes (primeiro)
app.UseSerilogRequestLogging();

// 2. Exception Handler (logo ap√≥s logging)
app.UseGlobalExceptionHandler();

// 3. CORS
app.UseCors("AllowFrontendApps");

// 4. HTTPS Redirection
app.UseHttpsRedirection();

// 5. Swagger (dev only)
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// 6. Authentication/Authorization
app.UseAuthentication();
app.UseAuthorization();

// 7. Controllers
app.MapControllers();
```

## üé® Estrutura de Exce√ß√µes Recomendada
```
CatalogService.Domain/
‚îú‚îÄ‚îÄ Exceptions/
‚îÇ   ‚îú‚îÄ‚îÄ CatalogDomainException.cs (base)
‚îÇ   ‚îú‚îÄ‚îÄ Products/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProductNotFoundException.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DuplicateSlugException.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DuplicateSkuException.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ InsufficientStockException.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ InvalidPriceException.cs
‚îÇ   ‚îú‚îÄ‚îÄ Categories/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CategoryNotFoundException.cs
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CircularCategoryReferenceException.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CategoryHasProductsException.cs
‚îÇ   ‚îî‚îÄ‚îÄ Reviews/
‚îÇ       ‚îú‚îÄ‚îÄ DuplicateReviewException.cs
‚îÇ       ‚îî‚îÄ‚îÄ ReviewNotAllowedException.cs

CatalogService.Api/
‚îú‚îÄ‚îÄ Middlewares/
‚îÇ   ‚îî‚îÄ‚îÄ GlobalExceptionHandlerMiddleware.cs
‚úÖ Benef√≠cios desta Abordagem

Separa√ß√£o Clara: Dom√≠nio lan√ßa exce√ß√µes, Application coordena, API padroniza
C√≥digo Limpo: Controllers e handlers sem try-catch desnecess√°rios
Consist√™ncia: Todas as respostas seguem o padr√£o ApiResponse
Rastreabilidade: Logs estruturados em cada camada
Testabilidade: F√°cil testar exce√ß√µes de dom√≠nio isoladamente
Manutenibilidade: Um √∫nico ponto para mapear exce√ß√µes ‚Üí HTTP status codes

üìã Diretrizes de Uso
‚úÖ LANCE EXCE√á√ïES quando:

Viola√ß√£o de regra de dom√≠nio (ex: estoque insuficiente)
Entidade n√£o encontrada
Opera√ß√£o inv√°lida no estado atual
Dados inconsistentes que impedem a opera√ß√£o

‚ùå N√ÉO LANCE EXCE√á√ïES para:

Valida√ß√£o de input (use ValidationHandler)
Fluxos de neg√≥cio esperados (ex: cupom expirado ‚Üí retorne ApiResponse)
Erros de autoriza√ß√£o (use AuthorizationFilter)

Essa abordagem est√° alinhada com seu projeto e aproveita o ApiResponse que voc√™ j√° implementou! üöÄTentar novamenteBDanalise a estrutura e o fluxo dos meus commands desde o controllerüîç An√°lise Detalhada do Fluxo de Commands
Vou analisar o fluxo completo desde o Controller at√© o Domain, identificando pontos fortes e oportunidades de melhoria.
üìä Fluxo Atual Analisado
1Ô∏è‚É£ Controller Layer ‚úÖ BOM
csharp// CategoryController.cs (linhas relevantes)
[HttpPost]
public async Task<IActionResult> CreateCategory(
    [FromBody] CreateCategoryCommand command, 
    CancellationToken cancellationToken = default)
{
    try
    {
        _logger.LogInformation("üìù Iniciando cria√ß√£o de categoria: {CategoryName}", command.Name);

        // ‚úÖ BOM: Valida√ß√£o de ModelState
        if (!ModelState.IsValid)
        {
            var errorHandler = new ValidationHandler();
            errorHandler.Add("Dados inv√°lidos.");
            return BadRequest(ApiResponse<CreateCategoryResponse>.Fail(errorHandler.Errors.ToList()));
        }

        // ‚úÖ BOM: Usa Mediator
        var result = await _mediator.SendAsync<ApiResponse<CreateCategoryResponse>>(
            command, cancellationToken);

        if (result.Success && result.Data != null)
        {
            return CreatedAtAction(nameof(CreateCategory), new { id = result.Data.Id }, result);
        }

        return BadRequest(result);
    }
    catch (ArgumentException ex)
    {
        // ‚ö†Ô∏è PROBLEMA: Captura espec√≠fica desnecess√°ria
        return BadRequest(ApiResponse<CreateCategoryResponse>.Fail(...));
    }
    catch (Exception ex)
    {
        // ‚ö†Ô∏è PROBLEMA: Tratamento gen√©rico no controller
        return StatusCode(500, ApiResponse<CreateCategoryResponse>.Fail(...));
    }
}
‚ùå Problemas Identificados:

Try-catch excessivo: Controller n√£o deveria tratar exce√ß√µes
ModelState validation: Redundante com validator
Exception handling duplicado: Entre controller e middleware
Logging verboso: Muitos emojis e detalhes


2Ô∏è‚É£ Command ‚úÖ EXCELENTE
csharp// CreateCategoryCommand.cs
public class CreateCategoryCommand : ICommand<ApiResponse<CreateCategoryResponse>>
{
    public string Name { get; set; } = string.Empty;
    public string Slug { get; set; } = string.Empty;
    public string? Description { get; set; }
    public Guid? ParentId { get; set; }
    public int DisplayOrder { get; set; } = 0;
    public bool IsActive { get; set; } = true;
    public string Metadata { get; set; } = "{}";
}
‚úÖ Pontos Fortes:

DTO simples e focado
Properties com valores default apropriados
Implementa ICommand<TResponse> corretamente

üîÑ Sugest√µes:
csharp// Adicionar data annotations para valida√ß√£o b√°sica
public class CreateCategoryCommand : ICommand<ApiResponse<CreateCategoryResponse>>
{
    [Required(ErrorMessage = "Nome √© obrigat√≥rio")]
    [MaxLength(200, ErrorMessage = "Nome deve ter no m√°ximo 200 caracteres")]
    public string Name { get; set; } = string.Empty;

    [Required(ErrorMessage = "Slug √© obrigat√≥rio")]
    [MaxLength(200)]
    [RegularExpression(@"^[a-z0-9]+(?:-[a-z0-9]+)*$", 
        ErrorMessage = "Slug deve conter apenas letras min√∫sculas, n√∫meros e h√≠fens")]
    public string Slug { get; set; } = string.Empty;

    [MaxLength(1000)]
    public string? Description { get; set; }

    public Guid? ParentId { get; set; }

    [Range(0, int.MaxValue)]
    public int DisplayOrder { get; set; } = 0;

    public bool IsActive { get; set; } = true;

    [Required]
    public string Metadata { get; set; } = "{}";
}

3Ô∏è‚É£ Validator ‚úÖ BOM (mas pode melhorar)
csharp// CreateCategoryCommandValidator.cs
public class CreateCategoryCommandValidator
{
    public ValidationHandler Validate(CreateCategoryCommand command)
    {
        var handler = new ValidationHandler();
        
        if (string.IsNullOrWhiteSpace(command.Name))
            handler.Add("Nome da categoria √© obrigat√≥rio");
        else if (command.Name.Length > 200)
            handler.Add("Nome da categoria deve ter no m√°ximo 200 caracteres");
        
        // ... mais valida√ß√µes
        
        return handler;
    }
}
‚ö†Ô∏è Problemas:

N√£o usa FluentValidation: Framework padr√£o da ind√∫stria
L√≥gica duplicada: Mesmas regras que Data Annotations
Valida√ß√£o de JSON manual: Poderia ser mais robusta

‚ú® Refatora√ß√£o Recomendada:
csharp// Instalar: FluentValidation.AspNetCore
public class CreateCategoryCommandValidator : AbstractValidator<CreateCategoryCommand>
{
    private readonly ICategoryRepository _categoryRepository;

    public CreateCategoryCommandValidator(ICategoryRepository categoryRepository)
    {
        _categoryRepository = categoryRepository;

        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("Nome da categoria √© obrigat√≥rio")
            .MaximumLength(200).WithMessage("Nome deve ter no m√°ximo 200 caracteres")
            .MustAsync(BeUniqueNameAsync).WithMessage("J√° existe uma categoria com este nome")
            .When(x => !string.IsNullOrEmpty(x.Name));

        RuleFor(x => x.Slug)
            .NotEmpty().WithMessage("Slug √© obrigat√≥rio")
            .MaximumLength(200).WithMessage("Slug deve ter no m√°ximo 200 caracteres")
            .Matches(@"^[a-z0-9]+(?:-[a-z0-9]+)*$")
                .WithMessage("Slug inv√°lido")
            .MustAsync(BeUniqueSlugAsync).WithMessage("Slug j√° existe");

        RuleFor(x => x.Description)
            .MaximumLength(1000)
            .When(x => !string.IsNullOrEmpty(x.Description));

        RuleFor(x => x.DisplayOrder)
            .GreaterThanOrEqualTo(0);

        RuleFor(x => x.Metadata)
            .NotEmpty()
            .Must(BeValidJson).WithMessage("Metadata deve ser um JSON v√°lido");

        RuleFor(x => x.ParentId)
            .MustAsync(ParentExistsAsync).WithMessage("Categoria pai n√£o encontrada")
            .When(x => x.ParentId.HasValue);
    }

    private async Task<bool> BeUniqueNameAsync(string name, CancellationToken ct)
    {
        var existing = await _categoryRepository.FindAsync(c => c.Name == name, ct);
        return !existing.Any();
    }

    private async Task<bool> BeUniqueSlugAsync(CreateCategoryCommand command, string slug, CancellationToken ct)
    {
        var existing = await _categoryRepository.FindAsync(c => c.Slug == slug, ct);
        return !existing.Any();
    }

    private async Task<bool> ParentExistsAsync(Guid? parentId, CancellationToken ct)
    {
        if (!parentId.HasValue) return true;
        var parent = await _categoryRepository.GetByIdAsync(parentId.Value, ct);
        return parent != null;
    }

    private bool BeValidJson(string json)
    {
        try
        {
            JsonDocument.Parse(json);
            return true;
        }
        catch
        {
            return false;
        }
    }
}

4Ô∏è‚É£ Command Handler ‚ö†Ô∏è CR√çTICO - Precisa Melhorar
csharp// CreateCategoryCommandHandler.cs
public class CreateCategoryCommandHandler 
    : ICommandHandler<CreateCategoryCommand, ApiResponse<CreateCategoryResponse>>
{
    public async Task<ApiResponse<CreateCategoryResponse>> HandleAsync(
        CreateCategoryCommand request, 
        CancellationToken cancellationToken = default)
    {
        // ‚ùå PROBLEMA 1: Valida√ß√£o DENTRO do handler
        var validationResult = _validator.Validate(request);
        if (validationResult.HasErrors)
            return ApiResponse<CreateCategoryResponse>.Fail(validationResult.Errors.ToList());

        // ‚ùå PROBLEMA 2: Try-catch gen√©rico capturando tudo
        try
        {
            await _unitOfWork.BeginTransactionAsync(cancellationToken);

            // ‚ùå PROBLEMA 3: Valida√ß√£o de neg√≥cio no handler, n√£o no dom√≠nio
            var existingCategories = await _categoryRepository
                .FindAsync(c => c.Slug == request.Slug, cancellationToken);
            
            if (existingCategories.Any())
            {
                await _unitOfWork.RollbackTransactionAsync(cancellationToken);
                validationResult.Add("J√° existe uma categoria com este slug.");
                return ApiResponse<CreateCategoryResponse>.Fail(...);
            }

            // ‚úÖ BOM: Usa factory method do dom√≠nio
            var category = Category.Create(
                request.Name,
                request.Slug,
                request.Description,
                request.ParentId,
                request.DisplayOrder,
                request.IsActive,
                request.Metadata
            );

            await _categoryRepository.AddAsync(category, cancellationToken);
            await _unitOfWork.SaveChangesAsync(cancellationToken);
            await _unitOfWork.CommitTransactionAsync(cancellationToken);

            // ‚úÖ BOM: Mapeamento manual claro
            var response = new CreateCategoryResponse { ... };
            return ApiResponse<CreateCategoryResponse>.Ok(response, "...");
        }
        catch (ArgumentException ex)
        {
            // ‚ùå PROBLEMA 4: Tratamento duplicado de exce√ß√µes
            await _unitOfWork.RollbackTransactionAsync(cancellationToken);
            return ApiResponse<CreateCategoryResponse>.Fail(...);
        }
        catch (Exception ex)
        {
            // ‚ùå PROBLEMA 5: Engolindo exce√ß√µes gen√©ricas
            await _unitOfWork.RollbackTransactionAsync(cancellationToken);
            return ApiResponse<CreateCategoryResponse>.Fail($"Erro interno: {ex.Message}");
        }
    }
}
‚ùå Problemas Cr√≠ticos:

Valida√ß√£o no Handler: Deveria ser no pipeline (Behavior)
L√≥gica de Neg√≥cio Vazada: Verifica√ß√£o de slug duplicado deveria estar no validator ou dom√≠nio
Try-Catch Excessivo: Middleware deveria capturar
Transa√ß√£o Manual: Deveria ser autom√°tica via Behavior
Rollback Manual: Deveria ser autom√°tico em caso de exce√ß√£o


5Ô∏è‚É£ Domain Entity ‚úÖ EXCELENTE (mas com ressalvas)
csharp// Category.cs
public class Category : AggregateRoot
{
    public string Name { get; private set; }
    public string Slug { get; private set; }
    // ... outras propriedades

    private Category() { } // ‚úÖ BOM: EF Constructor

    // ‚úÖ EXCELENTE: Factory Method
    public static Category Create(
        string name,
        string slug,
        string? description = null,
        Guid? parentId = null,
        int displayOrder = 0,
        bool isActive = true,
        string metadata = "{}")
    {
        // ‚ùå PROBLEMA: Valida√ß√µes comentadas ou removidas
        // Deveria validar AQUI, n√£o no validator
        return new Category
        {
            Name = name,
            Slug = slug,
            Description = description,
            ParentId = parentId,
            IsActive = isActive,
            DisplayOrder = displayOrder,
            Metadata = metadata,
            Version = 1,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow
        };
    }

    // ‚úÖ BOM: M√©todo Validate separado
    public override ValidationHandler Validate(ValidationHandler handler)
    {
        if (string.IsNullOrWhiteSpace(Name))
            handler.Add("Nome da categoria √© obrigat√≥rio");
        
        // ... mais valida√ß√µes
        
        return handler;
    }
}
‚ö†Ô∏è Problema: Valida√ß√µes est√£o no m√©todo Validate(), mas n√£o s√£o chamadas automaticamente no Create().
‚ú® Refatora√ß√£o Recomendada:
csharppublic static Category Create(
    string name,
    string slug,
    string? description = null,
    Guid? parentId = null,
    int displayOrder = 0,
    bool isActive = true,
    string metadata = "{}")
{
    // ‚úÖ Validar SEMPRE na cria√ß√£o
    var category = new Category
    {
        Name = name,
        Slug = slug,
        Description = description,
        ParentId = parentId,
        IsActive = isActive,
        DisplayOrder = displayOrder,
        Metadata = metadata,
        Version = 1,
        CreatedAt = DateTime.UtcNow,
        UpdatedAt = DateTime.UtcNow
    };

    // ‚úÖ Valida√ß√£o autom√°tica
    var validationHandler = new ValidationHandler();
    category.Validate(validationHandler);
    validationHandler.ThrowIfHasErrors(); // ‚ùå Lan√ßa DomainException

    return category;
}
```

---

## üéØ Proposta de Fluxo Otimizado

### **Estrutura Ideal com Pipeline Behaviors**
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Controller  ‚îÇ  ‚Üê Remove try-catch, apenas chama Mediator
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  MediatR Pipeline    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 1. LoggingBehavior   ‚îÇ  ‚Üê Log entrada/sa√≠da
‚îÇ 2. ValidationBehavior‚îÇ  ‚Üê FluentValidation autom√°tica
‚îÇ 3. TransactionBehavior‚îÇ ‚Üê BeginTransaction/Commit autom√°tico
‚îÇ 4. ExceptionBehavior ‚îÇ  ‚Üê Captura exce√ß√µes e retorna ApiResponse
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Command      ‚îÇ  ‚Üê Handler limpo, s√≥ l√≥gica de neg√≥cio
‚îÇ Handler      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Domain     ‚îÇ  ‚Üê Valida√ß√µes de invariantes
‚îÇ   Entity     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
1. Validation Behavior (Pipeline)
csharp// Application/Behaviors/ValidationBehavior.cs
public class ValidationBehavior<TRequest, TResponse> 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICommand<TResponse>
    where TResponse : class
{
    private readonly IEnumerable<IValidator<TRequest>> _validators;
    private readonly ILogger<ValidationBehavior<TRequest, TResponse>> _logger;

    public ValidationBehavior(
        IEnumerable<IValidator<TRequest>> validators,
        ILogger<ValidationBehavior<TRequest, TResponse>> logger)
    {
        _validators = validators;
        _logger = logger;
    }

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        if (!_validators.Any()) 
            return await next();

        var context = new ValidationContext<TRequest>(request);
        
        var validationResults = await Task.WhenAll(
            _validators.Select(v => v.ValidateAsync(context, cancellationToken)));

        var failures = validationResults
            .SelectMany(r => r.Errors)
            .Where(f => f != null)
            .ToList();

        if (failures.Any())
        {
            _logger.LogWarning("‚ö†Ô∏è Validation failed for {CommandType}: {Errors}",
                typeof(TRequest).Name,
                string.Join(", ", failures.Select(f => f.ErrorMessage)));

            var errors = failures
                .Select(f => new Error(f.ErrorMessage))
                .ToList();

            // ‚úÖ Retorna ApiResponse tipado
            return CreateFailResponse<TResponse>(errors);
        }

        return await next();
    }

    private static TResponse CreateFailResponse<T>(List<Error> errors)
    {
        var responseType = typeof(T);
        
        if (responseType.IsGenericType && 
            responseType.GetGenericTypeDefinition() == typeof(ApiResponse<>))
        {
            var dataType = responseType.GetGenericArguments()[0];
            var failMethod = typeof(ApiResponse<>)
                .MakeGenericType(dataType)
                .GetMethod(nameof(ApiResponse<object>.Fail), new[] { typeof(List<Error>) });
            
            return (T)failMethod!.Invoke(null, new object[] { errors })!;
        }

        throw new InvalidOperationException($"Cannot create fail response for type {responseType}");
    }
}
2. Transaction Behavior (Pipeline)
csharp// Application/Behaviors/TransactionBehavior.cs
public class TransactionBehavior<TRequest, TResponse> 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICommand<TResponse>
{
    private readonly IUnitOfWork _unitOfWork;
    private readonly ILogger<TransactionBehavior<TRequest, TResponse>> _logger;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        var commandName = typeof(TRequest).Name;

        try
        {
            _logger.LogDebug("üîÑ Beginning transaction for {CommandName}", commandName);
            
            await _unitOfWork.BeginTransactionAsync(cancellationToken);
            
            var response = await next();
            
            await _unitOfWork.CommitTransactionAsync(cancellationToken);
            
            _logger.LogDebug("‚úÖ Transaction committed for {CommandName}", commandName);
            
            return response;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "üí• Transaction failed for {CommandName}, rolling back", commandName);
            
            await _unitOfWork.RollbackTransactionAsync(cancellationToken);
            
            throw; // Re-throw para ExceptionBehavior ou middleware tratar
        }
    }
}
3. Logging Behavior (Pipeline)
csharp// Application/Behaviors/LoggingBehavior.cs
public class LoggingBehavior<TRequest, TResponse> 
    : IPipelineBehavior<TRequest, TResponse>
    where TRequest : ICommand<TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;

    public async Task<TResponse> Handle(
        TRequest request,
        RequestHandlerDelegate<TResponse> next,
        CancellationToken cancellationToken)
    {
        var commandName = typeof(TRequest).Name;
        var stopwatch = Stopwatch.StartNew();

        _logger.LogInformation("üì• Executing {CommandName}", commandName);

        try
        {
            var response = await next();
            
            stopwatch.Stop();
            
            _logger.LogInformation("‚úÖ {CommandName} executed successfully in {ElapsedMs}ms",
                commandName, stopwatch.ElapsedMilliseconds);

            return response;
        }
        catch (Exception ex)
        {
            stopwatch.Stop();
            
            _logger.LogError(ex, "‚ùå {CommandName} failed after {ElapsedMs}ms",
                commandName, stopwatch.ElapsedMilliseconds);
            
            throw;
        }
    }
}
4. Command Handler Refatorado ‚ú®
csharp// CreateCategoryCommandHandler.cs - VERS√ÉO LIMPA
public class CreateCategoryCommandHandler 
    : ICommandHandler<CreateCategoryCommand, ApiResponse<CreateCategoryResponse>>
{
    private readonly ICategoryRepository _categoryRepository;
    private readonly ILogger<CreateCategoryCommandHandler> _logger;

    public CreateCategoryCommandHandler(
        ICategoryRepository categoryRepository,
        ILogger<CreateCategoryCommandHandler> logger)
    {
        _categoryRepository = categoryRepository;
        _logger = logger;
    }

    public async Task<ApiResponse<CreateCategoryResponse>> HandleAsync(
        CreateCategoryCommand request, 
        CancellationToken cancellationToken = default)
    {
        // ‚úÖ SEM valida√ß√£o - feita no Behavior
        // ‚úÖ SEM transa√ß√£o - gerenciada no Behavior
        // ‚úÖ SEM try-catch - tratado no Middleware
        // ‚úÖ SEM logging excessivo - feito no Behavior

        // Apenas l√≥gica de neg√≥cio pura
        var category = Category.Create(
            request.Name,
            request.Slug,
            request.Description,
            request.ParentId,
            request.DisplayOrder,
            request.IsActive,
            request.Metadata
        );

        await _categoryRepository.AddAsync(category, cancellationToken);
        
        // SaveChanges √© chamado automaticamente pelo TransactionBehavior
        // antes do Commit

        var response = new CreateCategoryResponse
        {
            Id = category.Id,
            Name = category.Name,
            Slug = category.Slug,
            Description = category.Description,
            ParentId = category.ParentId,
            IsActive = category.IsActive,
            DisplayOrder = category.DisplayOrder,
            CreatedAt = category.CreatedAt
        };

        return ApiResponse<CreateCategoryResponse>.Ok(
            response, 
            "Categoria criada com sucesso");
    }
}
5. Controller Refatorado ‚ú®
csharp// CategoryController.cs - VERS√ÉO LIMPA
[HttpPost]
[ProducesResponseType(typeof(ApiResponse<CreateCategoryResponse>), 201)]
[ProducesResponseType(typeof(ApiResponse<CreateCategoryResponse>), 400)]
public async Task<IActionResult> CreateCategory(
    [FromBody] CreateCategoryCommand command, 
    CancellationToken cancellationToken = default)
{
    // ‚úÖ SEM try-catch
    // ‚úÖ SEM valida√ß√£o manual
    // ‚úÖ SEM logging excessivo
    
    var result = await _mediator.SendAsync<ApiResponse<CreateCategoryResponse>>(
        command, cancellationToken);

    return result.Success 
        ? CreatedAtAction(nameof(GetCategoryById), new { id = result.Data.Id }, result)
        : BadRequest(result);
}
6. Configura√ß√£o no Program.cs
csharp// Program.cs - Configura√ß√£o de Behaviors

builder.Services.AddMediator(typeof(CreateCategoryCommandHandler).Assembly)
    .AddBehaviors(); // Extension method

// Extension Method
public static class MediatorExtensions
{
    public static IServiceCollection AddBehaviors(this IServiceCollection services)
    {
        // Ordem importa! Executam na ordem registrada
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(LoggingBehavior<,>));
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(ValidationBehavior<,>));
        services.AddScoped(typeof(IPipelineBehavior<,>), typeof(TransactionBehavior<,>));
        
        return services;
    }
}

// FluentValidation
builder.Services.AddValidatorsFromAssembly(typeof(CreateCategoryCommandValidator).Assembly);
```

---

## üìã Checklist de Refatora√ß√£o

### ‚úÖ Prioridade Alta

- [ ] Implementar `ValidationBehavior` com FluentValidation
- [ ] Implementar `TransactionBehavior` autom√°tico
- [ ] Remover try-catch dos Controllers
- [ ] Remover valida√ß√£o manual dos Handlers
- [ ] Adicionar `GlobalExceptionHandlerMiddleware`

### ‚úÖ Prioridade M√©dia

- [ ] Implementar `LoggingBehavior`
- [ ] Refatorar valida√ß√µes do dom√≠nio para serem chamadas no `Create()`
- [ ] Criar exce√ß√µes de dom√≠nio espec√≠ficas
- [ ] Adicionar Data Annotations nos Commands

### ‚úÖ Prioridade Baixa

- [ ] Implementar `PerformanceBehavior` (m√©tricas)
- [ ] Adicionar `CachingBehavior` (para queries)
- [ ] Implementar `RetryBehavior` (resilience)

---

## üéØ Resultado Final

**ANTES:**
```
Controller (90 linhas) 
  ‚Üí Handler (120 linhas) 
    ‚Üí Domain (30 linhas)
    
Total: 240 linhas
Responsabilidades: Duplicadas em cada camada
```

**DEPOIS:**
```
Controller (10 linhas)
  ‚Üí Pipeline Behaviors (3 x 40 linhas = 120 linhas, reutiliz√°veis)
    ‚Üí Handler (25 linhas)
      ‚Üí Domain (35 linhas)

Total: 190 linhas
Responsabilidades: Separadas e reutiliz√°veis
Benef√≠cios:

‚úÖ 20% menos c√≥digo
‚úÖ 0 duplica√ß√£o
‚úÖ Behaviors reutiliz√°veis em TODOS os commands
‚úÖ Handlers focados apenas em l√≥gica de neg√≥cio
‚úÖ Controllers limpos e simples
‚úÖ Dom√≠nio auto-valid√°vel

Quer que eu implemente algum desses behaviors especificamente? üöÄ